# 插入排序

插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法∶直接插入排序、折半插入排序和希尔排序。



## 1 直接插入排序

根据上面的插入排序思想，不难得出一种最简单也最直观的直接插入排序算法。假设在排序过程中，待排序表 $L[1…n]$ 在某次排序过程中的某一时刻状态如下∶

<div align=center>
    <image src='imgs/2-1.png' width=400>
    <h4><h>
</div>

要将元素 $L(i)$ 插入已有序的子序列 $L[1..i-1]$，需要执行以下操作（为避免混淆，下面用 $L[]$ 表示一个表，而用 $L()$ 表示一个元素）∶
- 查找出 $L(i)$ 在 $L[1…i-1]$ 中的插入位置k
- 将 $L[k..i-1]$中的所有元素依次后移一个位置
- 将 $L(i)$ 复制到 $L(k)$

为了实现对 $L[1…n]$ 的排序，可以将 $L(2)～L(n)$ 依次插入前面已排好序的子序列，初始 L[1] 可以视为是一个已排好序的子序列。上述操作执行n-1次就能得到一个有序的表。

插入排序在实现上通常采用就地排序（空间复杂度为 $O(1)$），因而在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。

>直接插入排序
```c++
void InserSort(ElemType A[], int n){
    int i, j;
    for(i=2; i<=n; i++){        // 依次将 A[2]~A[n] 插入前面已排序序列
        if(A[i]<A[i-1]){        // 若 A[i] 小于前驱
            A[0] = A[i];        // 复制为哨兵，A[0] 不存放元素
            for(j=i-1; A[0]<A[j]; --j)  // 从有序表后往前找插入位置
                A[j+1] = A[j];  // 向后挪位
            A[j+1] = A[0];      // 复制到插入的位置
        }
    }
}
```
假定初始序列为49，38，65，97，76，13，27，49，初始时49可以视为一个已排好序的子序列，按照上述算法进行直接插入排序的过程如图8.1所示，括号内是已排好序的子序列。



<div align=center>
    <image src='imgs/2-2.png' width=500>
    <h4><h>
</div>

>性能分析如下
- 空间效率∶仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$
- 时间效率∶在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。
    - 在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为 $O(n)$
    - 在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达到最大，为 $\sum\limits^n_{i=2}i$，总的移动次数也达到最大，为 $\sum\limits^n_{i=2}(i+1)$
    - 平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为平均情况下的时间复杂度，总的比较次数与总的移动次数均约为$n^2/4$。

因此，直接插入排序算法的时间复杂度为 $O(n^2)$。

稳定性∶由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序方法。

适用性∶直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。

注意∶大部分排序算法都仅适用于顺序存储的线性表。





&emsp;
## 2 折半插入排序



&emsp;
## 3 希尔排序