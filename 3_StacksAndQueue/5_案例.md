# 案例
&emsp;
# 1 数值的转换
十进制数 $N$ 和其它 $d$ 进制的转换是极端及实现计算的基本问题，其中一个简单的算法基于下列原理


<div align=center>
    <image src='imgs/数制的转换.png' width=600>
    <h4><h>
</div>


假设现要编制一个满足下列要求的程序∶
- 对于输入的任意一个非负十进制整数，输出与其等值的八进制数
- 上述计算过程是从低位到高位顺序产生八进制数的各个数位
- 而输出过程应从高位到低位进行，恰好和计算过程相反，因而我们可以使用栈来解决这个问题

在计算过程中依次将得到的余数压入栈中，计算完毕后，再依次弹出栈中的余数就是数制转换的结果

&emsp;
>案例分析

当将一个十进制整数 $N$ 转换为八进制数时，在计算过程中，把 $N$ 与 $8$ 求余得到的八进制数的各位依次进栈，计算完毕后将栈中的八进制数依次出栈输出，输出结果就是待求得的八进制数



&emsp;
>案例实现

在具体实现时，栈可以采用顺序存储表示也可以采用链式存储表示


&emsp;
>算法步骤
1. 初始化一个空栈 S
2. 当十进制数 N 非零时，循环执行以下操作
    - 把 N 与 8 求余得到的八进制数压入栈 S
    - N 更新为 N 与 8 的商
3. 当栈 S 非空时，循环执行以下操作
    - 弹出栈顶元素 e
    - 输出 e

&emsp;
>代码
```c++
void conversion(int N)
{
    SqStack S;
    SElemType e;

    initStack(&S);

    // 八进制数前面加 0
    printf("十进制数 %d 转换为八进制数为: 0", N);
    while ( N != 0)
    {
        push(&S, N % 8); // 进栈时从低位到高位
        N = N / 8;
    }

    while (!stackEmpty(S))
    {
        pop(&S, &e);     // 出栈时从高位到低位 
        printf("%d", e);
    }
    printf("\n");
}
```

&emsp;
>算法分析

显然，该算法的时间和空间复杂度均为 $O(log_8n)$

这是利用栈的后进先出特性的最简单的例子。在这个例子中，栈的操作是单调的，即先一味地入栈，然后一味地出栈

用数组直接实现不是更简单吗?

但仔细分析上述算法不难看出，栈的引入简化了程序设计的问题，划分了不同的关注层次，使思考范围缩小了。而用数组不仅掩盖了问题的本质，还要分散精力去考虑数组下标增减等细节问题。

在实际利用栈的问题中，入栈和出栈操作大都不是单调的，而是交错进行的。


&emsp;
# 2 括号匹配的检验
假设表达式中允许包含两种括号∶圆括号和方括号，其嵌套的顺序随意，即 `([]())` 或 `[([])]`等为正确的格式，`[(]`或 `([())` 或 `(()])` 均为不正确的格式。

检验括号是否匹配的方法可用“期待的急迫程度”这个概念来描述。例如，考虑下列括号序列∶
&emsp;
<div align=center>
    <image src='imgs/括号匹配.png' width=300>
    <h4><h>
</div>
&emsp;

当计算机接受了第一个括号后，它期待着与其匹配的第八个括号的出现，然而等来的却是第二个括号，显然第二个括号的期待急迫性高于第一个括号，此时第一个括号“[”只能暂时靠边，而迫切等待与第二个括号相匹配的、第七个括号“）”的出现。类似地，因等来的是第三个括号“[”，其期待匹配的程度较第二个括号更急迫，则第二个括号也只能靠边，让位于第三个括号。在接受了第四个括号之后，第三个括号的期待得到满足，消解之后，第二个括号的期待匹配就成为当前最急迫的任务了，……

依次类推。可见，这个处理过程恰与栈的特点相吻合。每读入一个括号，若是右括号，则或者使置于栈顶的最急迫的期待得以消解，或者是不合法的情况；若是左括号，则作为一个新的更急迫的期待压人栈中，自然使原有的在栈中的所有未消解的期待的急迫性都降了一级。

&emsp;
>案例分析

检验算法借助一个栈，每当读入一个左括号，则直接入栈，等待相匹配的同类右括号；每当读人一个右括号，若与当前栈顶的左括号类型相同，则二者匹配，将栈顶的左括号出栈，直到表达式扫描完毕。
在处理过程中，还要考虑括号不匹配出错的情况。例如，当出现（）【 D）这种情况时，由于前面入栈的左括号均已和后面出现的右括号相匹配，栈已空，因此最后扫描的右括号不能得到匹配；出现【（】）这种错误，当表达式扫描结束时，栈中还有一个左括号没有匹配；出现（）这种错误显然是栈顶的左括号和最后的右括号不匹配。


&emsp;
>算法步骤
1. 初始化一个空栈 S
2. 设置一标记性变量 flag，用来标记匹配结果以控制循环及返回结果，1 表示正确匹配，0 表示错误匹配，flag 初值为 1
3. 扫描表达式，一次读入字符 ch，如果表达式没有扫描完毕或 flag 非零，则循环执行以下操作：
    - 若 ch 是左括号 “[” 或 “(”，则将其压入栈
    - 若 ch 是右括号 “)”，则根据当前栈顶元素的值分情况考虑：若栈非空且栈顶元素是 “(”，则正确匹配，否则错误匹配，flag 置为 0
    - 若 ch 是右括号 “]”，则根据当前栈顶元素的值分情况考虑：若栈非空且栈顶元素是 “[”，则正确匹配，否则错误匹配，flag 置为 0
4. 退出循环后，如果栈空且 flag 值为 1，则匹配成功，返回 true，否则返回 false


&emsp;
>代码
```c++

```

>算法分析

此算法从头到尾扫描表达式中每个字符，若表达式的字符串长度为 $n$，则此算法的时间复杂度为 $O(n)$。算法在运行时所占用的辅助空间主要取决于 $S$ 栈的大小，显然，$S$ 栈的空间大小不会超过 $n$，所以此算法的空间复杂度也同样为 $O(n)$。



&emsp;
# 3 表达式求值
表达式求值是程序设计语言编译中的一个最基本问题，其实现是栈应用的又一个典型例子。“算符优先法”，是一种简单直观、广为使用的表达式求值算法。


&emsp;
>案例分析

任何一个表达式都是由
- 操作数（operand）：操作数既可以是常数，也可以是被说明为变量或常量的标识符
- 运算符（operator）：运算符可以分为算术运算符、关系运算符和逻辑运算符3类
- 界限符（delimiter）：基本界限符有左右括号和表达式结束符等

组成的，统称它们为单词。为了叙述的简洁，在此仅讨论简单算术表达式的求值问题，这种表达式只含加、减、乘、除4种运算符。

下面把运算符和界限符统称为算符。我们知道，算术四则运算遵循以下3条规则∶
1. 先乘除，后加减
2. 从左算到右
3. 先括号内，后括号外

<div align=center>
    <image src='imgs/运算符.png' width=600>
    <h4><h>
</div>

由规则（1），先进行乘除运算，后进行加减运算

由规则（2），运算遵循左结合性，当两个运算符相同时，先出现的运算符优先级高

由规则（3），括号内的优先级高，+、-、*和/为0时的优先性均低于“（”但高于“）”。

表中的“（”=“）”表示当左右括号相遇时，括号内的运算已经完成。为了便于实现，假设每个表达式均以“#”开始，以“#”结束。所以“#”=“#”表示整个表达式求值完毕。“）”与“（”、“#”与“）”以及“（”与“#”之间无伏先关系，这是因为表达式中不允许它们相继出现，一旦遇到这种情况，则可以认为出现了语法错误。在下面的讨论中，我们暂假定所输入的表达式不会出现语法错误。



&emsp;
>案例实现

为实现运算符优先算法，可以使用两个工作栈，一个叫 OPTR，用来寄存运算符；另一个叫 OPND，用来寄存操作数或运算结果

&emsp;
>算法步骤
1. 初始化 OPTR 栈和 OPND 栈，将表达式起始符 “#” 压入 OPTR 栈
2. 扫描表达式，读入第一个字符 ch，如果表达式没有扫描完毕至 “#” 或 OPTR 的栈顶元素不为 “#” 时，则循环执行以下操作：
    - 若 ch 不是运算符，则压入 OPND 栈，读入下一字符 ch
    - 若 ch 是运算符，则根据 OPTR 的栈顶元素和 ch 的优先级比较结果，做不同处理：
        - 若是小于，则 ch 压入 OPTR 栈，读入下一字符 ch；
        - 若是大于，则弹出 OPTR 栈顶的运算符，从 OPND 栈弹出两个数，进行相应运算，结果压入 OPND 栈
        - 若是等于，则 OPTR 的栈顶元素是"（"且ch是"）"，这时弹出OPTR栈顶的"（"，相当于括号匹配成功，然后读入下一字符 ch
3. OPND 栈顶元素即为表达式求值结果，返回此元素




&emsp;
>代码
```c++

```

&emsp;
>算法分析

此算法从头到尾扫描表达式中每个字符，若表达式的字符串长度为 $n$，则此算法的时间复杂度为 $O(n)$。算法在运行时所占用的辅助空间主要取决于 OPTR 栈和 OPND 栈的大小，显然，它们的空间大小之和不会超过 $n$，所以此算法的空间复杂度也同样为 $O(n)$

<div align=center>
    <image src='imgs/算术表达式的求值过程.png' width=600>
    <h4><h>
</div>


&emsp;
# 4 舞伴问题

假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头各出一人配成舞伴。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一算法模拟上述舞伴配对问题。
先入队的男士或女士应先出队配成舞伴，因此该问题具有典型的先进先出特性，可用队列作为算法的数据结构。
从上面的应用案例可以看出，不论是借助栈还是队列来解决问题，最基本的操作都是"入"和“出”。对于栈，在栈顶插入元素的操称作“人栈”，删除栈顶元素的操作称作“出栈”；对于队列，在队尾插入元素的操称作“入队”，在队头删除元素的操称作“出队”。和线性表一样，栈和队列的存储结构也包括顺序和链式两种。
本章后续章节将依次给出不同存储结构表示的栈和队列的基本操作，并介绍栈的一个非常重要的应用--在程序设计语言中来实现递归，借助栈的基本操作，读者可以深刻理解递归的处理机制。本章最后将利用栈和队列给出上述四个案例的具体实现。

&emsp;
>案例分析

对于舞伴配对问题，先入队的男士或女士先出队配成舞伴，因此设置两个队列分别存放男士和女士入队者。假设男士和女士的记录存放在一个数组中作为输入，然后依次扫描该数组的各元素，并根据性别来决定是进入男队还是女队。当这两个队列构造完成之后，依次将两队当前的队头元素出队来配成舞伴，直至某队列变空为止。此时，若某队仍有等待配对者，则输出此队列中排在队头的等待者的姓名，此人将是下一轮舞曲开始时第一个可获得舞伴的人


&emsp;
>案例实现
有关数据结构定义如下：
```c++

```


&emsp;
>算法步骤

1. 初始化Mdancers队列和Fdancers队列
2. 反复循环，依次将跳舞者根据其性别插入Mdancers队列或Fdancers队列
3. 当Mdancers队列和Fdancers队列均为非空时，反复循环，依次输出男女舞伴的姓名
4. 如果Mdancers队列为空而Fdancers队列非空，则输出Fdancers队列的队头女士的姓名
5. 如果Fdancers队列为空而Mdancers队列非空，则输出Mdancers队列的队头男士的姓名


&emsp;
>代码
```c++

```

&emsp;
>算法分析

若跳舞者人数总计为 $n$，则此算法的时间复杂度为 $O(n)$。空间复杂度取决于 Mdancers 队列和 Fdancers 队列的长度，二者长度之和不会超过 $n$，因此空间复杂度也同样为 $O(n)$。

队列在程序设计中也有很多应用，凡是符合先进先出原则的数学模型，都可以用队列。最典型的例子是操作系统中用来解决主机与外设之间速度不匹配问题或多个用户引起的资源竞争问题。

