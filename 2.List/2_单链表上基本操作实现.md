# 单链表上基本操作实现

## 1 采用头插法建立单链表
该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后。

<div align=center>
    <image src='imgs/2-1.png' width=400>
    <h4>头插法建立单链表<h>
</div>

采用头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。每个结点插入的时间为 $O(1)$，设单链表长为 $n$，则总时间复杂度为 $O(n)$。

思考一下∶若没有设立头结点，则上述代码需要在哪些地方修改

&emsp;
## 2 采用尾插法建立单链表
头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序不一致。若希望两者次序一致，则可采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针r，使其始终指向当前链表的尾结点。

<div align=center>
    <image src='imgs/2-2.png' width=400>
    <h4>尾插法建立单链表<h>
</div>

因为附设了一个指向表尾结点的指针，故时间复杂度和头插法的相同。

&emsp;
## 3 按序号查找结点值
在单链表中从第一个结点出发，顺指针 next 域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。

按序号查找操作的时间复杂度为O（n）

&emsp;
## 4 按值查找表结点
从单链表的第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回 NULL。

按值查找操作的时间复杂度为O（n）

&emsp;
## 5 插入结点操作
插入结点操作将值为x的新结点插入到单链表的第 i 个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第 i-1 个结点，再在其后插入新结点。

算法首先调用按序号查找算法GetElem（L，i-1），查找第 i-1 个结点。假设返回的第 i-1 个结点为 *p，然后令新结点 *s 的指针域指向 *p 的后继结点，再令结点 *p 的指针域指向新插入的结点 *s

<div align=center>
    <image src='imgs/2-3.png' width=400>
    <h4>单链表的插入操作<h>
</div>

>实现插入结点
```c++
p = GetElem(L, i-1);
s-
>next = p->next;
p->next = s;
```

算法中，语句②和③的顺序不能颠倒，否则，当先执行p->next=s后，指向其原后继的指针就不存在，再执行s->next=p->next时，相当于执行了s->next=s，显然是错误的。本算法主要的时间开销在于查找第i-1个元素，时间复杂度为 $O(n)$。若在给定的结点后面插入新结点，则时间复杂度仅为 $O(1)$。

&emsp;
### 扩展: 对某一结点进行前插操作。
前插操作是指在某结点的前面插入一个新结点，后插操作的定义刚好与之相反。在单链表插入算法中，通常都采用后插操作。

以上面的算法为例，首先调用函数 GetElem() 找到第 i-1 个结点，即插入结点的前驱结点后，再对其执行后插操作。由此可知，对结点的前插操作均可转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为 $O(n)$。

此外，可采用另一种方式将其转化为后插操作来实现，设待插入结点为*s，将*s插入到*p 的前面。我们仍然将*s插入到*p的后面，然后将p->data与s->data交换，这样既满足了逻辑关系，又能使得时间复杂度为O（1）。算法的代码片段如下∶

>前插
```c++
s->next = p->next;
p->next = s;
temp = p->data;
p->data = s->data;
s->data = emp;
```

&emsp;
## 6 删除结点操作
删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，后查找表中第 i-1 个结点，即被删结点的前驱结点，再将其删除。

<div align=center>
    <image src='imgs/2-4.png' width=400>
    <h4>单链表的插入操作<h>
</div>

假设结点 \*p 为找到的被删结点的前驱结点，为实现这一操作后的逻辑关系的变化，仅需修改 \*p 的指针域，即将 \*p 的指针域 next 指向 \*q 的下一结点。

>删除结点
```c++
p = GetElem(L, i-1);
q = p->next;
p->next = q->next;
free(q);
```

和插入算法一样，该算法的主要时间也耗费在查找操作上，时间复杂度为 $O(n)$。扩展删除结点 *p。

要删除某个给定结点 *p，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后执行删除操作，算法的时间复杂度为 $O(n)$。

其实，删除结点 \*p 的操作可用删除 *p 的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为 $O(1)$。

```c++
//令q指向*p的后继结点q=p->next;
//和后继结点交换数据域
p->data=p->next->data;//将*q结点从链中“断开”p->next=q->next;
//释放后继结点的存储空间
free(q);
```

&emsp;
## 7 求表长操作
求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。算法的时间复杂度为$O(n)$。

需要注意的是，因为单链表的长度是不包括头结点的，因此不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。

单链表是整个链表的基础，读者一定要熟练掌握单链表的基本操作算法。在设计算法时，建议先通过图示的方法理清算法的思路，然后进行算法的编写。

















