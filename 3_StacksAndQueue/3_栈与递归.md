&emsp;
# 栈与递归

&emsp;
# 1 采用递归算法解决的问题

## 1.1 定义是递归的
&emsp;
### （1）二阶 Fibonacci 数列
$$Fib(n) = \begin{cases}
1, & \text{若 n = 1 或 n = 2} \\
Fib(n-1) + Fib(n-2), &\text{其它情形}
\end{cases}$$

>代码
```c++
long Fib(long n)
{
    if (n == 1 || n ==2) return 1;  // 递归终止条件
    else return Fib(n-1) + Fib(n-2) // 递归步骤
}
```
&emsp;
### （2）阶乘函数
$$Fact(n) = \begin{cases}
1, & \text{若 n = 0} \\
n*Fact(n-1), &\text{若 n > 0}
\end{cases}$$

>代码
```c++
long Fact(long n)
{
    if (n == 0) return 1;    // 递归终止条件
    else return n*Fact(n-1); // 递归步骤
}
```

<div align=center>
    <image src='imgs/递归.png' width=400>
    <h4>求解 4! 的过程<h>
</div>


&emsp;
>用分治法进行递归求解需要满足以下三个条件
1. 能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，并且这些处理对象更小且变化有规律
2. 可以通过上述转化而使问题简化
3. 必须有一个明确的递归出口，或称递归的边界

>分治法求解递归问题算法的一般形式
```c++
void p(参数表)
{
    if (递归结束条件成立) 可直接求解; // 递归终止的条件
    else p(较小的参数);            // 递归步骤
}
```


&emsp;
## 1.2 数据结构是递归的
某些数据结构本身具有递归的特性，则它们的操作可递归地描述

例如，对于链表，其结点 LNode 的定义由数据域 data 和指针域 next 组成，而指针域 next 是一种指向 LNode 类型的指针，即 LNode 的定义中又用到了其自身，所以链表是一种递归的数据结构

对于递归的数据结构，相应算法采用递归的方法来实现特别方便。链表的创建和链表结点的
遍历输出都可以采用递归的方法

>遍历输出链表中各个结点的递归算法
1. 如果 p 为 NULL，递归结束返回
2. 否则输出 p->data，p 指向后继结点继续递归
```c++
void TraverseList(LinkList p)
{
    if (p == NULL) return;      // 递归终止
    else
    {
        printf("%d ", p->data); // 输出当前结点的数据域
        TraverseList(p->next);  // p 指向后继结点继续递归
    }
}
```

简化
```c++
void TraverseList(LinkList p)
{
    if (p)
    {
        printf("%d ", p->data);
        TraverseList(p->next);
    }
}
```

&emsp;
## 1.3 问题解法是递归的
还有一类问题，虽然问题本身没有明显的递归结构，但用递归求解比迭代求解更简单，如Hanoi 塔问题、八皇后问题、迷宫问题等。

&emsp;
### n 阶 Hanoi 塔问题
>问题描述

假设有 3 个分别命名为 A、B 和 C 的塔座，在塔座 A 上插有 n 个直径大小各不相同，依小到大编号为 1，2，…，n 的圆盘。现要求将塔座 A 上的 n 个圆盘移至塔座 C 上，并仍按同样顺序叠排，圆盘移动时必须遵循下列规则∶
1. 每次只能移动一个圆盘
2. 圆盘可以插在A、B和C中的任一塔座上
3. 任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。


&emsp;
# 2 递归过程与递归工作栈
## 2.1 任意两个函数之间的调用过程
一个递归函数，在函数的执行过程中，需多次进行自我调用。递归函数是如何执行的?先看任意两个函数之间进行调用的情形

与汇编语言程序设计中主程序和子程序之间的链接及信息交换相类似，在高级语言编制的程序中，调用函数和被调用函数之间的链接及信息交换需通过栈来进行

通常，当在一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成 3 件事
1. 将所有的实参、返回地址等信息传递给被调用函数保存
2. 为被调用函数的局部变量分配存储区
3. 将控制转移到被调函数的人口

而从被调用函数返回调用函数之前，系统也应完成3件工作∶
1. 保存被调函数的计算结果
2. 释放被调函数的数据区
3. 依照被调函数保存的返回地址将控制转移到调用函数

当有多个函数构成嵌套调用时，按照"后调用先返回"的原则，上述函数之间的信息传递和控制转移`必须通过“栈”来实现`，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区，每当从一个函数退出时，就释放它的存储区，则当前正运行的函数的数据区必在栈顶

<div align=center>
    <image src='imgs/栈3.png' width=500>
    <h4>求解 4! 的过程<h>
</div>

如图所示的主函数 main 中调用了函数 first，而在函数 first 中又调用了函数 second，则（a）所示为当前正在执行函数 second中 某个语句时栈的状态，而（b）展示从函数 second 退出之后正执行函数 first 中某个语句时栈的状态（图中以语句标号表示返回地址）。

&emsp;
## 2.2递归工作栈
一个递归函数的运行过程类似于多个函数的嵌套调用，只是调用函数和被调用函数是同一个函数，因此，和每次调用相关的一个重要概念是递归函数运行的"层次"。

假设调用该递归函数的主函数为第0层，则从主函数调用递归函数为进入第1层；从第i层递归调用本函数为进入“下一层”，即第i+1层。反之，退出第i层递归应返回至“上一层”，即第i-1层。

为了保证递归函数正确执行，系统需设立一个“递归工作栈”作为整个递归函数运行期间使用的数据存储区。

每一层递归所需信息构成一个工作记录，其中包括
- 所有的实参
- 所有的局部变量
- 以及上一层的返回地址

每进入一层递归，就产生一个新的工作记录压入栈顶。每退出一层递归，就从栈顶弹出一个工作记录，则当前执行层的工作记录必是递归工作栈栈顶的工作记录，称这个记录为“活动记录”。

&emsp;
## 2.3 示例：求解 4! 活动记录


&emsp;
>main 函数
```c++
void main()
{
    long n;      // 调用 Fact(4) 是记录进栈
    n = Fact(4); // 返回地址 RetLoc1 在赋值语句
}
```

>Fact 函数
```c++
long Fact(long n)
{
    long temp;
    if (n==0) 
        return 1; // 活动记录退栈
    else 
    {
        temp = n*Fact(n-1); // 活动记录进栈
                            // 返回地址 RetLoc2 在计算语句
        return temp;        // 活动记录退栈
    }
}
```
&emsp;
<div align=center>
    <image src='imgs/栈4.png' width=500>
    <h4>求解 4! 的进栈出栈过程<h>
</div>
&emsp;

- 这里暂忽略局部变量 temp 的入栈和出栈情况
- RetLoc2是递归调用Fact（n-1）的返回地址
- 当Fact（n-1）结束后，返回到RetLoc2，在此处计算n*（n-1）!
- 然后将结果赋给临时变量tempa




&emsp;
# 3 递归算法的效率分析
## 3.1 时间复杂度的分析
下面以阶乘的递归函数 $Fact(n)$ 为例，说明通过迭代法求解递归方程来计算时间复杂度的
方法。

设 $Fact(n)$的执行时间是 $T(n)$。此递归函数中
- 语句 if（n==0）return 1；的执行时间是 $O(1)$
- 递归调用 $Fact(n-1)$的执行时间是 $T(n-1)$
- 所以 else return n*Fact（n-1）；的执行时间是 $O(1)+T(n-1)$

其中，设两数相乘和赋值操作的执行时间为 $O(1)$，则对于常数 $C_1$、$C_2$ 有如下递归方程
$$T(n) = \begin{cases}
C_1，          & n = 0    & \quad（1）\\
C_2 + T(n-1)， & n \geq 1 & \quad（2）
\end{cases}$$

当 $n = 2$ 时，$n-1 \geq 1$，满足（2）式，有： 

$T(n) = C_2 + T(n - 1) = C_2 + (C_2 + T(n-2)) = 2C_2 + T(0)$

所以，当 $n = 2$ 时，$T(n)= C_1 + 2C_2+T(0)$

&emsp;

当 $n = 3$ 时，$n-1 \geq 1$，$n-2 \geq 1$，满足（2）式，有： 

$T(n) = C_2 + T(n - 1) = C_2 + (C_2 + T(n-2)) = C_2 + (C_2 + (C_2 + T(n-3)) = 3C_2 + T(n-3) = 3C_2 + T(0)$

所以，当 $n = 3$ 时，$T(n) = C_1+ 3C_2+T(0)$


&emsp;

分析规律得：当 $n = i$ 时，有：
$$T(n) = iC_2 + T(n-i)$$

即
$$T(n) = C_1 + nC_2$$

&emsp;
## 3.2 空间复杂度的分析
递归函数在执行时，系统需设立一个“递归工作栈”存储每一层递归所需的信息，此工作栈是递归函数执行的辅助空间，因此，分析递归算法的空间复杂度需要分析工作栈的大小。

对于递归算法，空间复杂度
$$S(n)=O(f(n))$$
其中，$f(n)$ 为“递归工作栈”中工作记录的个数与问题规模n的函数关系。

根据这种分析方法不难得到，前面讨论的阶乘问题、Fibonacci 数列问题、Hanoi 塔问题的递归算法的空间复杂度均为 $O(n)$



&emsp;
# 4 利用栈将递归转换为非递归

递归程序在执行时，需要系统提供隐式栈这种数据结构来实现。

对于一般的递归过程，仿照递归算法执行过程中递归工作栈的状态变化可直接写出相应的非递归算法。这种利用栈消除递归过程的步骤如下
1. 设置一个工作栈存放递归工作记录（包括实参、返回地址及局部变量等）
2. 进入非递归调用入口（即被调用程序开始处）将调用程序传来的实在参数和返回地址入栈（递归程序不可以作为主程序，因而可认为初始是被某个调用程序调用）
3. 进入递归调用入口∶当不满足递归结束条件时，逐层递归，将实参、返回地址及局部变量入栈，这一过程可用循环语句来实现———模拟递归分解的过程
4. 递归结束条件满足，将到达递归出口的给定常数作为当前的函数值
5. 返回处理∶ 在栈不空的情况下，反复退出栈顶记录，根据记录中的返回地址进行题意规定的操作，即逐层计算当前函数值，直至栈空为止———模拟递归求值过程




