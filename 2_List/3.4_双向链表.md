
&emsp;
# 4 双向链表
前面讨论的链式存储结构的结点中只有一个指示直接后继的指针域。

由此，从某个结点出发只能顺指针向后寻查其他结点。若要寻查结点的直接前驱，则必须从表头指针出发。换句话说，在单链表中，查找直接后继结点的执行时间为 $O(1)$，而查找直接前驱的执行时间为 $O(n)$

为克服单链表这种单向性的缺点，可利用`双向链表（Double Linked List ）`

&emsp;
## 4.1 双向链表的定义
- 在双向链表的结点中有两个指针域
    - 一个指向直接后继
    - 另一个指向直接前驱

在C语言中可描述如下∶
```c++
typedef struct DouLNode
{
    ElemType data;          // 数据域
    struct DouLNode *prior; // 直接前驱
    struct DouLNode *next;  // 直接后驱
}DouLNode, *DouLinkList;
```

和单链的循环表类似，双向链表也可以有循环表，如下图所示

<div align=center>
    <image src='imgs/双向链表.png' width=600>
    <h4>双向链表<h>
</div>


&emsp;
## 4.2 双向链表的操作及实现
在双向链表中，有些操作（如 ListLength、GetElem 和 LocateElem 等）仅需涉及一个方向的指针，则它们的算法描述和线性链表的操作相同

但在插入、删除时有很大的不同在双向链表中需同时修改两个方向上的指针
- 在插入结点时需要修改四个指针
- 在删除结点时需要修改两个指针
- 两者的时间复杂度均为 O（n）

<div align=center>
    <image src='imgs/双向链表2.png' width=600>
    <h4>双向链表<h>
</div>

>双向链表打印
```c++
void printList(DouLinkList pL)
{
    if (!pL)
        return ERROR;
    DouLNode *pMove = pL;
    while(pMove->next != pL) // 判断条件与单链表不同
    {
        printf("%d ", pMove->next->data);
        pMove = pMove->next;
    }
    printf("\n");
}
```

&emsp;
### （1）初始化
>代码
```c++
//（1）初始化
Status initList(DouLinkList *ppL)
{
    *ppL = (DouLinkList)malloc(sizeof(DouLinkList));
    if (!ppL)
        exit(OVERFLOW);
    
    // 前驱和后继都指向自身
    (*ppL)->next = (*ppL)->prior = *ppL;
}
```

&emsp;
### （2）插入

>代码
```c++
//（2）插入
Status listInsert(DouLinkList pL, int i, ElemType e)
{
    if (!pL)
    {
        printf("[WARNING]: LIST NOT EXIST!\n");
        return ERROR;
    }

    DouLNode *pMove = pL;
    int count = -1;

    // 遍历到第 i 个结点
    while(pMove->next != pL && count < i)
    {
        pMove = pMove->next;
        count++;
    }
    
    // 判断越界
    // 此时 pMove 为第 i 个结点
    // 或者如果 i 超过头结点，责问为头结点的前一结点，此时 count = 表的元素数
    // i < 0 || i 超过了头结点的位置
    if (i < 0 || count + 1 < i)
    {
        printf("[WARNING]: INVALID INDEX!\n");
        return ERROR;
    }
    
    DouLNode *pNewNode = (DouLNode*)malloc(sizeof(DouLNode));
    if (!pNewNode)
        exit(OVERFLOW);
    
    pNewNode->data = e;

    // 将 pNewNode 插入到 pMove 的位置，称为第 i 个结点
    pNewNode->next     = pMove;
    pNewNode->prior    = pMove->prior;
    pMove->prior->next = pNewNode;
    pMove->prior       = pNewNode;

    return OK;
}
```

>注意
- 下面两句的前后顺序不能调换
```c++
pMove->prior->next = pNewNode;
pMove->prior       = pNewNode;
```
- 如果调换成为
```c++
pMove->prior       = pNewNode;
pMove->prior->next = pNewNode;
```
- 后面要用到，prior->next，但是 prior 已经更改过了

&emsp;
## 4.4 删除

>代码
```c++
//（3）删除
Status listDelete(DouLinkList pL, int i, ElemType *pE)
{
    // 确保链表存在并且
    if (!pL || pL->next == pL || pL->prior == pL)
        return ERROR;
    
    // 
    DouLNode *pMove = pL;
    int count = -1;
    // 遍历到第 i 个点
    while(pMove->next != pL && count < i)
    {
        printf("while loop\n");
        pMove = pMove->next;
        count++;
    }
    printf("count = %d\n", count);
    // 判断越界
    if (i < 0 || count+1 < i)
    {
        printf("[WARNING]: INVALID INDEX!");
        return ERROR;
    }
    
    *pE = pMove->data;

    // 移除 pMove 结点
    pMove->prior->next = pMove->next;
    pMove->next->prior = pMove->prior;

    free(pMove);
    return OK;
}
```


&emsp;
## 4.5 查找
>代码
```c++
//（4）查找
int locateElem(DouLinkList pL, ElemType e)
{
    // 确保链表存在并且不为空
    if (!pL || pL->next == pL || pL->prior == pL)
    {
        printf("[WARNING]: LIST NOT EXIST OR EMPTY LIST!");
        return ERROR;
    }

    DouLNode *pMove = pL;
    int count = -1;
    // 
    while (pMove->next != pL && pMove->data != e)
    {
        pMove = pMove->next;
        count++;
    }

    if (pMove != pL)
        return count;
    else    
        return 0;
}
```


&emsp;
## 4.6 取值
>代码
```c++
//（5）取值
Status getElem(DouLinkList pL, int i, ElemType *pE)
{
    if (!pL || pL->next == pL || pL->prior == pL)
    {
        printf("[WARNING]: LIST NOT EXIST OR EMPTY LIST!\n");
        return ERROR;
    }

    DouLNode *pMove = pL;
    int count = -1;
    while(pMove->next != pL && count < i)
    {
        pMove = pMove->next;
        count++;
    }

    if (i < 0 || count+1 < i)
    {
        printf("[WARNING]: INVALID INDEX!\n");
        return ERROR;
    }
    *pE = pMove->data;
    return OK;
}
```