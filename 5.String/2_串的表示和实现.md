&emsp;
# 串的表示和实现


&emsp;
# 1 定长顺序存储表示

类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述∶

```c++
/* 宏定义 */
#define MAXSTRLEN 255 // 顺序串的最大串长

/*
 * 串的顺序存储类型定义
 * 注：有效元素从SString的1号单元开始存储
 *     SString的0号单元用来存储其长度
 */
typedef unsigned char SString[MAXSTRLEN + 1]; // 0号单元存放串的长度
```
串的实际长度可在这预定义长度的范围内随意，超过预定义长度的串值则被舍去，称之为"截断"。

对串长有两种表示方法∶
- 一是如上述定义描述的那样，以下标为 0 的数组分量存放串的实际长度，如 PASCAL语言中的串类型采用这种表示方法;
- 二是在串值后面加一个不计入串长的结束标记字符，如在有的 C 语言中以"\0"表示串值的终结。 此时的串长为隐含值，显然不便于进行某些串操作。

在这种存储结构表示时如何实现串的操作，下面以串联接和求子串为例来讨论

&emsp;
## 1.1 串联接
```c++
Concat(&T, S1, S2)
```

假设 S1、S2 和 T 都是 SString 型的串变量，且串 T 是由串 S1 联结串 S2 得到的，即串 T 的值的前一段和串 S1 的值相等，串 T 的值的后一段和串 S2 的值相等，则只要进行相应的"串值复制"操作即可，只是需按前述约定，对超长部分实施"截断"操作。

基于串 S1 和 S2 长度的不同情况，串 T 值的产生可能有如下3种情况∶
1. S1[0]＋S2[0] ≤ MAXSTRLEN，如图（a）所示，得到的串 T 是正确的结果

<div align=center>
    <image src='./imgs/串a.png' width=300>
    <h4><h>
</div>


2. S1[0] < MAX-STRLEN 而 S1[0]＋S2[0] > MAXSTRLEN，则将串 S2 的一部分截断，得到的串 T只包含串 S2 的一个子串，如图（b）所示:

<div align=center>
    <image src='./imgs/串b.png' width=300>
    <h4><h>
</div>

3. S1[0] = MAXSTRLEN，则得到的串 T 并非联接结果，而和串 S1 相等

<div align=center>
    <image src='./imgs/串c.png' width=300>
    <h4><h>
</div>


>代码
```c++

```

&emsp;
## 1.2 求子串
```c++
SubString(&Sub, S, pos, len)
```

求子串的过程即为复制字符序列的过程，将串 S 中从第 pos 个字符开始长度为 len 的字符序列复制到串 Sub 中。显然，本操作不会有需截断的情况，但有可能产生用户给出的参数不符合操作的初始条件，当参数非法时，返回 ERROR。

>代码
```c++

```

&emsp;
## 1.3 小结

综上两个操作可见，在顺序存储结构中，实现串操作的原操作为"字符序列的复制"，操作的时间复杂度基于复制的字符序列的长度。另一操作特点是，如果在操作中出现串值序列的长度超过上界 MAXSTRLEN 时，约定用截尾法处理，这种情况不仅在求联接串时可能发生，在串的其他操作中，如插入、置换等也可能发生。克服这个弊病惟有不限定串长的最大长度，即动态分配串值的存储空间。



&emsp;
# 2 堆分配存储表示
这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间是在程序执行过程中动态分配而得。

在 C 语言中，存在一个称之为"堆"的自由存储区，并由C语言的动态分配函数 `malloc()` 和 `free()` 来管理。利用函数 `malloc()` 为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时，为了以后处理方便，约定串长也作为存储结构的一部分。

```c++
/*
 * 串的堆存储表示
 * 注：有效元素从ch的0号单元开始存储
 */
typedef struct {
    char* ch;           // 若是非空串，则按串长分配存储区，否则ch为NULL
    int length;
} HString;
```



&emsp;
# 3 串的块链存储表示

<div align=center>
    <image src='./imgs/串1.png' width=500>
    <h4>串值的链表存储方式<h>
</div>



```c++
/* 宏定义 */
#define CHUNKSIZE 3     // 块大小（自定义）

/* 串的块链存储结构 */
typedef struct Chunk {
    char ch[CHUNKSIZE];  // 当前块中的内容
    struct Chunk* next;  // 指向下一个块
} Chunk;

/* 串的块链存储类型定义 */
typedef struct {
    Chunk* head;    //串的头指针
    Chunk* tail;    //串的尾指针
    int curlen;     //串的当前长度
} LString;
```

在链式存储方式中，结点大小的选择直接影响着串处理的效率。在各种串的处理系统中，所处理的串往往很长或很多，如一本书的几.百万个字符。情报资料的成千上万个条目。这就要求考虑串值的存储密度。

显然，存储密度小（如结点大小为1时），运算处理方便，然而，存储占用量大。如果在串处理过程中需进行内、外存交换的话，则会因为内、外存交换操作过多而影响处理的总效率。应该看到，串的字符集的大小也是一个重要因素。一般来说，字符集小，则字符的机内编码就短，这也影响串值存储方式的选取。

串值的链式存储结构对某些串操作，如联接操作等，有一定方便之处。但总地说来.不如顺序存储结构灵活，它占用存储量大且操作复杂。


