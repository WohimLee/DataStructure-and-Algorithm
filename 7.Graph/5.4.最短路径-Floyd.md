&emsp;
# 最短路径 —— Floyd 

求所有顶点之间的最短路径问题描述如下: 已知一个各边权值均大于 0 的带权有向图, 对任意两个顶点 $v_i \neq v_j$, 要求求出 $v_i$ 与 $v_j$ 之间的最短路径和最短路径长度。

Floyd 算法的基本思想是: 递推产生一个 $n$ 阶方阵序列 $A^{(-1)}, A^{(0)}, \cdots, A^{(k)}, \cdots, A^{(n-1)}$, 其中 $A^{(k)}[i][j]$表示从顶点 $v_i$ 到顶点 $v_j$ 的路径长度, $k$ 表示绕行第 $k$ 个顶点的运算步骤。初始时, 对于任意两个顶点 $v_i$ 和 $v_j$, 若它们之间存在边, 则以此边上的权值作为它们之间的最短路径长度; 若它们之间不存在有向边, 则以 $\infty$ 作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点 $k(k=0$, $1, \cdots, n-1)$ 作为中间顶点。若增加中间顶点后, 得到的路径比原来的路径长度减少了, 则以此新路径代替原路径。算法描述如下:
定义一个 $n$ 阶方阵序列 $A^{(-1)}, A^{(0)}, \cdots, A^{(n-1)}$, 其中,
$$
\begin{gathered}
A^{(-1)}[i][j]=\operatorname{arcs}[i][j] \\
A^{(k)}[i][j]=\operatorname{Min}\left\{A^{(k-1)}[i][j], \quad A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\right\}, \quad k=0,1, \cdots, n-1
\end{gathered}
$$

式中, $A^{(0)}[i][j]$ 是从顶点 $v_i$ 到 $v_j$ 、 中间顶点是 $v_0$ 的最短路径的长度, $A^{(k)}[i][j]$ 是从顶点 $v_i$ 到 $v_j$ 、中间顶点的序号不大于 $k$ 的最短路径的长度。Floyd 算法是一个迭代的过程, 每迭代一次, 在从 $v_i$到 $v_j$ 的最短路径上就多考虑了一个顶点; 经过 $n$ 次迭代后, 所得到的 $A^{(n-1)}[i][j]$ 就是 $v_i$ 到 $v_j$ 的最短路径长度, 即方阵 $A^{(n-1)}$ 中就保存了任意一对顶点之间的最短路径长度。

图 6.19 所示为带权有向图 $G$ 及其邻接矩阵。应用 Floyd 算法求所有顶点之间的最短路径长度的过程如表 6.2 所示。算法执行过程的说明如下。