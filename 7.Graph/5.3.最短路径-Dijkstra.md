&emsp;
# 最短路径 —— Dijkstra 

## 1 Intro
Dijkstra 算法设置一个集合 $S$ 记录已求得的最短路径的顶点, 初始时把源点 $v_0$ 放入 $S$, 集合 $S$ 每并入一个新顶点 $v_i$, 都要修改源点 $v_0$ 到集合 $V-S$ 中顶点当前的最短路径长度值 (这里可能不太好理解? 没关系, 等下就会清楚)。


在构造的过程中还设置了两个辅助数组:
- `dist []` : 记录从源点 $v_0$ 到其他各顶点当前的最短路径长度, 它的初态为: 若从 $v_0$ 到 $v_i$有弧, 则 dist [i] 为弧上的权值; 否则置 dist [i] 为 $\infty$
- `path []` : path [i] 表示从源点到顶点 $i$ 之间的最短路径的前驱结点。在算法结束时, 可根据其值追溯得到源点 $v_0$ 到顶点 $v_i$ 的最短路径。
假设从顶点 0 出发, 即 $v_0=0$, 集合 $S$ 最初只包含顶点 0 , 邻接矩阵 arcs 表示带权有向图, $\operatorname{arcs}[i][j]$ 表示有向边 $<i, j>$ 的权值, 若不存在有向边 $<i, j>$, 则 $\operatorname{arcs}[i][j]$ 为 $\infty$


&emsp;
## 2 算法步骤
Dijkstra 算法的步骤如下 (不考虑对 path [] 的操作):
1. 初始化: 集合 $S$ 初始为 $\{0\}$, dist [ ] 的初始值 $\operatorname{dist}[i]=\operatorname{arcs}[0][i] ， i=1,2, \cdots, n-1$ 。
2. 从顶点集合 $V-S$ 中选出 $v_j$, 满足 $\operatorname{dist}[j]=\operatorname{Min}\left\{\operatorname{dist}[i] \mid v_{\mathrm{i}} \in \mathrm{V}-\mathrm{S}\right\}, v_j$ 就是当前求得的一条从 $v_0$ 出发的最短路径的终点, 令 $S=S \cup\{j\}$
3. 修改从 $v_0$ 出发到集合 $V-S$ 上任一顶点 $v_k$ 可达的最短路径长度: 若 $\operatorname{dist}[j]+\operatorname{arcs}[j][k]<\operatorname{dist}[k]$, 则更新 $\operatorname{dist}[k]=\operatorname{dist}[j]+\operatorname{arcs}[j][k]$ 。
4. 重复 2） 3）操作共 $n-1$ 次, 直到所有的顶点都包含在 $S$ 中。
步骤 3）也就是开头留下的疑问, 每当一个顶点加入 $S$ 后, 可能需要修改源点 $v_0$ 到集合 $V-S$中可达顶点当前的最短路径长度, 下面举一简单例子证明。如下图所示, 源点为 $v_0$, 初始时 $S=\left\{v_0\right\}$, dist[1]=3, dist[2]=7, 当将 $v_1$ 并入集合 $S$ 后, dist[2] 需要更新为 4


>思考: Dijkstra 算法与 Prim 算法有何相似之处?

例如, 对图 6.17 中的图应用 Dijkstra 算法求从顶点 1 出发至其余顶点的最短路径的过程, 如表 6.1 所示。算法执行过程的说明如下。




显然, Dijkstra 算法也是基于贪心策略的。
使用邻接矩阵表示时, 时间复杂度为 $O\left(||^2\right)$ 。使用带权的邻接表表示时, 虽然修改 dist [ ]的时间可以减少, 但由于在 dist [ ] 中选择最小分量的时间不变, 时间复杂度仍为 $O\left(\mid V^2\right)$ 。

人们可能只希望找到从源点到某个特定顶点的最短路径, 但这个问题和求解源点到其他所有顶点的最短路径一样复杂, 时间复杂度也为 $O\left(|V|^2\right)$ 。

值得注意的是, 边上带有负权值时, Dijkstra 算法并不适用。若允许边上带有负权值, 则在与 $S$ (已求得最短路径的顶点集, 归入 $S$ 内的结点的最短路径不再变更) 内某点（记为 $a$ ) 以负边相连的点 (记为 $b$ ) 确定其最短路径时, 其最短路径长度加上这条负边的权值结果可能小于 $a$ 原先确定的最短路径长度, 而此时 $a$在 Dijkstra 算法下是无法更新的。例如, 对于图 6.18 所示的带权有向图, 利用 Dijkstra 算法不一定能得到正确的结果。