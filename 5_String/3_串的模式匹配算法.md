



&emsp;
# 3 串的模式匹配算法

子串的定位运算通常称为串的模式匹配或串匹配。此运算的应用非常广泛，比如在搜索引擎、拼写检查、语言翻译、数据压缩等应用中，都需要进行串匹配。

串的模式匹配设有两个字符串 S 和 T，设 S 为主串，也称正文串;设T为子串，也称为模式。在主串 S 中查找与模式 T 相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串 S 中出现的位置。

著名的模式匹配算法有 BF算法和 KMP算法，下面详细介绍这两种算法。

&emsp;
## 3.1 BF 算法
最简单直观的模式匹配算法是 BF（Brute-Force）算法。

模式匹配不一定是从主串的第一个位置开始，可以指定主串中查找的起始位置 pos。如果采用字符串顺序存储结构，可以写出不依赖于其他串操作的匹配算法。

>算法步骤

1. 分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置，i 初值为 pos，初值为1。
2. 如果两个串均未比较到串尾，即i和j均分别小于等于S和 T的长度时，则循环执行以下操作∶
    - S[i].ch 和 T[j].ch 比较，若相等，则 i 和 j 分别指示串中下个位置，继续比较后续字符;
    - 若不等，指针后退重新开始匹配，从主串的下一个字符（i=i-j+2）起再重新和模式的
第一个字符（j=1）比较
3. 如果 j>T.length，说明模式T中的每个字符依次和主串 S 中的一个连续的字符序列相等，则匹配成功，返回和模式 T 中第一个字符相等的字符在主串 S 中的序号（i-T.length）;否则称匹配不成功，返回0。


>代码
```c++

```


>算法分析







&emsp;
## 3.2 KMP 算法

这种改进算法是由 Knuth、Morris 和 Pratt 同时设计实现的，incident简称 KMP 算法。此算法法可以在 O（n+ m）的时间数量级上完成串的模式匹配操作。其改进在于;每当一趟匹配过程中出现字符比较不等时，不需回溯i指针，而是利用已经得到的"部分匹配"的结果将模式向右"滑动"尽可能远的一段距离后，继续进行比较。下面先从具体例子看起。
回顾图4.4中的匹配过程示例，在第三趟的匹配中，当i=7、j=5字符比较不等时，又从i=4、j=1重新开始比较。然后，经仔细观察可发现，i=4和j=1，i=5和 j=1，以及i=6和j=1这3次比较都是不必进行的。因为从第三趟部分匹配的结果就可得出，主串中第 4个、第5个和第6 个字符必然是"b"、"c"和"a"（即模式串中第2个、第3个和第4个字符）。因为模式中的第一个字符是"a"，因此它无需再和这3个字符进行比较，而仅需将模式向右滑动3个字符的位置继续进行 i=7、j=2时的字符比较即可。同理，在第一趟匹配中出现字符不等时，仅需将模式向右移动两个字符的位置继续进行i=3、j=1时的字符比较。由此，在整个匹配的过程中，i指针没有回溯，如图4.5所示。



<div align=center>
    <image src='imgs/KMP.png' width=400>
    <h4>KMP 算法的匹配过程<h>
</div>



>代码
```c++

```