&emsp;
# 2 单链表基本操作的实现
>链表的打印
```c++
// 方法一：借用链表长度
void printList(LinkList pL)
{
    LNode* temp = pL->next;
    for (int i = 0; i < pL->data; i++)
    {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// 方法二：借用 next
void printList(LinkList pL)
{
    while (pL->next)
    {
        printf("%d ", (pL->next)->data);
        pL = pL->next;
    }
    printf("\n");
}
```
## 2.1 初始化
单链表的初始化操作就是构造一个空表



&emsp;
>步骤
1. 生成新结点作为头结点，用头指针 L 指向头结点
2. 头结点的指针域置空

&emsp;
>代码
```c++
// （1）初始化
Status InitList(LinkList L)
{
    L = (LinkList)malloc (sizeof(LNode));
    if (!L) // 也可以写 L == NULL
        exit(OVERFLOW);
}
```


&emsp;
## 2.2 取值
- 只能从链表首元结点触发，顺着链域 next 逐个结点向下访问
&emsp;
>步骤
1. 用指针 $p$ 指向首元结点，用 $count$ 做计数器初值赋为 $1$
2. 从首元结点开始一次顺着链域 next 向下访问，只要指向当前结点的指针 $p$ 不为空（NULL），并且没有到达序号为 $i$ 的结点，则循环执行以下操作：
    - $p$ 指向下一个结点
    - 计数器 $count$ 相应加 $1$
3. 退出循环时
    - 如果指针 $p$ 为空，或者计数器 $count$ 大于 $i$，说明指定的序号 $i$ 值不合法（$i$ 大于表长 $n$ 或 $i$ 小于等于 $0$），取值失败返回 $ERROR$
    - 否则取值成功，次数 $count = i$ 时，$p$ 所指的结点就是要找的第 $i$ 个结点
    - 用参数 $e$ 保存当前结点的数据域，返回 $OK$
&emsp;
>代码
```c++
// （2）取值
Status GetElem(LinkList pL, int i, ElemType *pE)
{   
    // 确保链表存在且不为空
    if (!pL || !pL->next)
        return ERROR;
    
    LNode *pMove = pL; // 
    int count = -1;     // 计数器，-1 为头结点
    // 遍历到第 i-1 个点，且该点有后继 next 结点（即第 i 个元素）

    while(pMove->next && count < i-1)
    {
        pMove = pMove->next;
        count++;
    }
    // 此时 pMove 是第 i-1 个点
    // 如果 pMove 没有后继 next 结点（i 大于表长） || i 小于 0
    if (!pMove->next || count > i-1)
    {
        printf("[WARNING]: OUT OF RANGE!");
        return ERROR;
    }
    // 此时 pMove 是第 i-1 个点，取其 next 的数据域 data
    *pE = (pMove->next)->data;
    return OK;
}
```
&emsp;
>算法分析

该算法的基本操作是：比较 count 和 i 并后移指针 pMove，while 循环体重语句频度与位置 i 有关：
- 如果 $1 \leq i \leq n$，则频度为 $i-1$，一定能取值成功
- 如果 $i \geq n$，则频度为 $n$，取值失败

假设每个位置上元素的取值概率相等，即
$$p_i = 1/n$$
则
$$ASL = \frac{1}{n}\sum\limits_{i=1}^n(i-1)=\frac{n-1}{2}$$
由此可见，单链表取值算法那的凭据时间复杂度为 $O(n)$

&emsp;
## 2.3 查找
&emsp;
>步骤
1. 用指针 $p$ 指向首元结点
2. 从首元结点开始一次顺着链域 next 向下查找，只要指向当前结点的指针 $p$ 不为空，并且 $p$ 所指结点的数据域不等于给定值 $e$，则循环执行操作：$p$ 指向下一个结点
3. 返回 $p$。若查找成功，$p$ 此时即为结点的地址值，若查找失败，$p$ 的值即为 $NULL$

&emsp;
>代码
```c++
// （3）查找
LNode *LocateElem(LinkList pL, ElemType e)
{
    // 确保链表存在且不为空表
    if (!pL || !pL->next)
        return 0;
    
    int i = 0;               // 
    LNode *pMove = pL->next; // 
    while (pMove && pMove->data != e)
    {
        pMove = pMove->next;
        i++;
    }
    if (pMove != NULL)
        return i;
    else
    {
        printf("[WARNING]: NONE!");
        return -1;
    }
}
```
&emsp;
>算法分析

该算法的执行时间与待查找的值 e 相关，其平均时间复杂度分析与取值相似，也为 $O(n)$

&emsp;
## 2.4 插入
假设要在单链表的两个元素 a 和 b 之间插入一个数据元素 x，一直 p 为指向结点 a 的指针，如下图所示：

<div align=center>
    <image src='imgs/单链表插入0.png' width=500>
    <h4>在单链表中插入结点的指针变化<h>
</div>


```c++
s->next = p->next;
p->next = s;
```

&emsp;
>步骤
- 将值为 e 的新结点插入到表的第 i 个结点的位置上，即插入到结点 $a_{i-1}$ 与 $a_i$ 之间
    1. 查找结点 $a_{i-1}$ 并由指针 $p$ 指向该结点
    2. 生成一个新结点 $*s$
    3. 将新结点 $*s$ 的数据域置为 $e$
    4. 将新结点 $*s$ 的指针域指向结点 $a$
    5. 将新结点 $*p$ 的指针域指向新结点 $*s$

&emsp;
>代码
```c++
// （4）插入（默认已存在链表，且元素个数大于1）
Status ListInsert(LinkList pL, int i, ElemType e)
{
    if (!pL)
        return ERROR;
    
    LNode *pMove = (LNode*)malloc(sizeof(LNode));
    pMove = pL;     // 给 pMove 赋初值为头结点
    int count = -1; // -1 是头结点
    // 遍历到第 i-1 个结点
    while (pMove && count < i-1)
    {
        pMove = pMove->next;
        count++;
    }

    // 此时 pMove 是第 i-1 个结点
    // 如果 pMove 不存在 || i 的位置 < 0
    if (!pMove || count > i-1)
    {
        printf("[WARNING]: INVALID INDEX!\n");
        return ERROR;
    }
   
    // 生成新结点
    LNode *pNewNode = (LNode*)malloc(sizeof(LNode));
    if (!pNewNode)
        exit(OVERFLOW);

    pNewNode->data = e;
    pNewNode->next = pMove->next;
    pMove->next = pNewNode;
    
    return OK;
}
```
&emsp;
>算法分析

<div align=center>
    <image src='imgs/单链表插入.png' width=500>
    <h4>在单链表第 i 个位置上插入新结点的过程<h>
</div>

这个算法在第 i 个结点之前插入一个新结点，必须首先找到第 i-1 个结点，其时间复杂度与取值相同，为 $O(n)$。

&emsp;
## 2.5 删除
- 删除同插入一样，首先应该找到该位置的前驱结点。如下图：

<div align=center>
    <image src='imgs/单链表中删除1.png' width=500>
    <h4>单标中删除节点时指针的变化<h>
</div>

仅需修改结点 a 中的指针域即可，并且释放结点 b 所占的空间，所以在修改指针前，引入另一指针 q，临时保存结点 b 的地址以备释放

```c++
p->next = p->next->next
```

&emsp;
>步骤
1. 查找结点 $a_{i-1}$ 并由指针 p 指向该结点
2. 临时保存待删除结点 $a_i$ 的地址在 $q$ 中，以备释放
3. 将结点 $*p$ 的指针域指向 $a_i$ 的直接后继点
4. 释放结点 $a_i$ 的空间

&emsp;
>代码
```c++
// （5）删除
Status ListDelete(LinkList pL, int i, ElemType *pE)
{
    // 确保链表存在，且不为空表
    if (!pL || !pL->next)
        return ERROR;
    
    LNode *pMove = pL;
    int count = -1;

    // 遍历到第 i-1 个结点，且该结点有后继结点（即第 i 个结点） 
    // && i >= 0
    while (pMove->next && count < i-1)
    {
        pMove = pMove->next;
        count++;
    }

    // 此时 pMove 为第 i-1 个结点
    // 如果第 i-1 个结点 的 next 为NULL || i < 0
    // 说明 i 值不合法
    if (!pMove->next || count > i-1)
    {
        printf("[WARNING]: INVALID INDEX!");
        return ERROR;
    }
    
    // 删除第 i 个结点
    LNode *pTemp;
    pTemp = pMove->next;
    pMove->next = pTemp->next;
    *pE = pTemp->data;

    free(pTemp);
    return OK;
}
```
&emsp;
>算法分析
类似于插入算法，删除算法时间复杂度也是 $O(n)$

<div align=center>
    <image src='imgs/删除2.png' width=500>
    <h4>单标中删除节点时指针的变化<h>
</div>


&emsp;
## 2.6 创建单链表
如何建立一个包括若干个结点的链表呢?

- 链表和顺序表不同，它是一种动态结构
- 整个可用存储空间可为多个链表共同享用，每个链表占用的空间不需预先分配划定，而是由系统按需即时生成
- 因此，建立线性表的链式存储结构的过程就是一个动态生成链表的过程。即从空表的初始状态起，依次建立各元素结点，并逐个插人链表

（1）前插法
- 算法复杂度为 $O(n)$
- 将新结点逐个插人链表的头部（头结点之后）来创建链表
- 每次申请一个新结点，读入相应的数据元素值，然后将新结点插入到头结点之后

&emsp;
>步骤
1. 创建一个只有头结点的空链表
2. 根据待创建链表包括的元素个数 $n$，循环 $n$ 次执行以下操作
    - 生成一个新结点 $*p$
    - 输入元素值赋给新结点 $*p$ 的数据域
    - 将新结点 $*p$ 插入到头结点之后

<div align=center>
    <image src='imgs/前插1.png' width=500>
    <h4>前插法创建单链表<h>
</div>

&emsp;
>代码
```c++
// （6）创建单链表（前插）
Status CreateList_Head(LinkList *ppHeadNode, int n)
{
    LNode *pNewNode;
    // 建立头结点
    *ppHeadNode = (LinkList)malloc(sizeof(LNode));
    (*ppHeadNode)->next = NULL;

    for (int i = 0; i < n; ++i)
    {
        pNewNode = (LNode*)malloc(sizeof(LNode));

        printf("请输入数据：");
        scanf("%d", &(pNewNode->data));

        pNewNode->next = (*ppHeadNode)->next;
        (*ppHeadNode)->next = pNewNode;
        (*ppHeadNode)->data++;
    }
    return OK;
}
```

（2）后插法
- 算法复杂度为 $O(n)$
- 将新结点逐个插入到链表的尾部来创建链表
- 每次申请一个新结点，读入相应的数据元素值
- 与前插法不同的是，为了使新结点能够插入到表尾，需要增加一个尾指针 $r$ 指向链表的尾结点

&emsp;
>步骤
1. 创建一个只有头结点的空链表

2. 根据待创建链表包括的元素个数 $n$，循环 $n$ 次执行以下操作
    - 生成一个新结点 $*p$
    - 输入元素值赋给新结点 $*p$ 的数据域
    - 将新结点 $*p$ 插入到头结点之后

<div align=center>
    <image src='imgs/后插1.png' width=500>
    <h4>后插法创建单链表<h>
</div>

&emsp;
>代码
```c++
// （6）创建单链表（后插）
Status CreateList_Tail(LinkList *ppHeadNode, int n)
{
    *ppHeadNode = (LinkList)malloc(sizeof(LNode));
    (*ppHeadNode)->next = NULL;

    LNode *pNewNode, *pTailNode;
    pTailNode = (LNode*)malloc(sizeof(LNode));
    pTailNode->next = (*ppHeadNode);
    for (int i = 0; i < n; ++i)
    {
        pNewNode = (LNode*)malloc(sizeof(LNode));
        printf("请输入数据：");
        scanf("%d", &(pNewNode->data));

        (pTailNode->next)->next = pNewNode;
        pTailNode->next = pNewNode;
        (*ppHeadNode)->data++;
    }
    pTailNode->next = NULL;
    return OK;
}
```





